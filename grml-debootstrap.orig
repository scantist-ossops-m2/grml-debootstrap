#!/bin/bash
# Filename:      grml-debootstrap
# Purpose:       wrapper around debootstrap for installing plain Debian via Grml
# Authors:       grml-team (grml.org), (c) Michael Prokop <mika@grml.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2+
################################################################################
# http://www.debian.org/releases/stable/i386/index.html.en

set -e # exit on any error

# variables {{{
PN="$(basename $0)"
VERSION="$(dpkg --list $PN 2>/dev/null| awk '/^i/ {print $3}')"
VERSION="${VERSION:-unknown}"
MNTPOINT="/mnt/debootstrap.$$"

# inside the chroot system locales might not be available, so use minimum:
export LANG=C
export LC_ALL=C

# make sure interactive mode is only executed when
# using an empty configuration file or option --interactive
INTERACTIVE=''
# }}}

# source core functions {{{
. /etc/grml/lsb-functions
. /etc/grml/script-functions
# }}}

# help text {{{
usage() {
  echo "$PN - wrapper around debootstrap for installing Debian

Usage: $PN [options]

Bootstrap options:

  -m, --mirror <URL>     Mirror which should be used for apt-get/aptitude.
  -i, --iso <mnt>        Mountpoint where a Debian ISO is mounted to, for use
                           instead of fetching packages from a mirror.
  -r, --release <name>   Release of new Debian system (default: lenny).
  -t, --target <target>  Target partition (/dev/...) or directory where the
                         system should be installed to.
  -p, --mntpoint <mnt>   Mountpoint used for mounting the target system,
                         has no effect if -t is given and represents a directory.
      --debopt <params>  Extra parameters passed to the debootstrap command.
      --interactive      Use interactive mode (frontend).
      --nodebootstrap    Skip debootstrap, only do configuration to the target.
      --grub <device>    Target for grub installation. Usage example: /dev/sda
      --arch <arch>      Architecture to use. Currently only i386 is supported.
      --filesystem <fs>  Filesystem that should be used when target is a partition.
      --insecure         Do not download and check Release file signatures.

Configuration options:

  -c, --config <file>      Use specified configuration file, defaults to
                             /etc/debootstrap/config
  -d, --confdir <path>     Place of config files for debootstrap, defaults
                             to /etc/debootstrap
      --packages <file>    Install packages defined in specified list file.
      --nopackages         Skip installation of packages defined in
                             /etc/debootstrap/packages
      --debconf <file>     Pre-seed packages using specified pre-seed db file.
      --keep_src_list      Do not overwrite user provided apt sources.list.
      --hostname <name>    Hostname of Debian system.
      --password <pwd>     Use specified password as password for user root.
      --bootappend <line>  Add specified appendline to kernel whilst booting.
      --chroot-scripts <d> Execute chroot scripts from specified directory.
      --pre-scripts <dir>  Execute scripts from specified directory (before chroot-scripts).
      --scripts <dir>      Execute scripts from specified directory (after chroot-scripts).

Other options:

  -v, --verbose            Increase verbosity.
  -h, --help               Print this usage information and exit.
  -V, --version            Show summary of options and exit.

Usage examples can be found in the grml-debootstrap manpage.
Send bugreports to the grml-team: bugs (at) grml.org || http://grml.org/bugs/
"
}

if [ "$1" = '-h' ] || [ "$1" = '-help' ] || [ "$1" = "--help" ] ; then
   usage
   echo 'Please notice that this script requires root permissions!'
   exit 0
fi
# }}}

# make sure we have what we need {{{
check4progs debootstrap dialog || exit 1
# }}}

# source main configuration file {{{
if [ -r /etc/debootstrap/config ] ; then
  . /etc/debootstrap/config
fi
# }}}

# cmdline handling {{{
# source external command line parameter-processing script
if [ -r ./cmdlineopts.clp ] ; then
   . ./cmdlineopts.clp
elif [ -r /usr/share/grml-debootstrap/functions/cmdlineopts.clp ] ; then
   . /usr/share/grml-debootstrap/functions/cmdlineopts.clp
else
   echo "Error: cmdline function file not found, exiting.">&2
   exit 1
fi

# == business-logic of command line parameter-processing

# source configuration file in <confdir> if supplied. {{{
[ "$_opt_confdir" ] && {
  CONFFILES=$_opt_confdir
  einfo "Using config files under $CONFFILES/."
  if ! [ -r "$CONFFILES/config" ] ; then
    eerror "Error: config file $CONFFILES/config not found."; eend 1; exit 1
  fi
  if ! . "$CONFFILES/config" ; then
    eerror "Error reading config file $CONFFILES/config" ; eend 1 ; exit 1
  fi
  # restore the command line parameter value
  CONFFILES=$_opt_confdir
}
# }}}

[ "$_opt_mirror" ]              && MIRROR=$_opt_mirror
[ "$_opt_iso" ]                 && ISO=$_opt_iso
[ "$_opt_release" ]             && RELEASE=$_opt_release
[ "$_opt_target" ]              && TARGET=$_opt_target
[ "$_opt_mntpoint" ]            && MNTPOINT=$_opt_mntpoint
[ "$_opt_debopt" ]              && DEBOOTSTRAP_OPT=$_opt_debopt
[ "$_opt_interactive" ]         && INTERACTIVE=1
[ "$_opt_config" ]              && CONFIGFILE=$_opt_config
[ "$_opt_filesystem" ]          && MKFS="mkfs.$_opt_filesystem"
[ "$_opt_packages_set" ]        && PACKAGES='yes'
[ "$_opt_nopackages" ]          && PACKAGES=''
[ "$_opt_debconf_set" ]         && DEBCONF='yes'
[ "$_opt_scripts_set" ]         && SCRIPTS='yes'
[ "$_opt_pre_scripts_set" ]     && PRE_SCRIPTS='yes'
[ "$_opt_chroot_scripts_set" ]  && CHROOT_SCRIPTS='yes'
[ "$_opt_keep_src_list" ]       && KEEP_SRC_LIST='yes'
[ "$_opt_hostname" ]            && HOSTNAME=$_opt_hostname
[ "$_opt_password" ]            && ROOTPASSWORD=$_opt_password
[ "$_opt_bootappend" ]          && BOOT_APPEND=$_opt_bootappend
[ "$_opt_grub" ]                && GRUB=$_opt_grub
[ "$_opt_arch" ]                && ARCH=$_opt_arch
[ "$_opt_insecure" ]            && SECURE='false'
[ "$_opt_verbose" ]             && VERBOSE="-v"

[ "$_opt_help" ] && {
  usage ; eend 0
  eend 0
  exit 0
}

[ "$_opt_version" ] && {
  einfo "$PN - version $VERSION"
  einfo "Send bug reports to bugs@grml.org or http://grml.org/bugs/"
  eend 0
  exit 0
}
# }}}

# check for root permissions {{{
if ! check4root ; then
   echo "For usage instructions please execute '$PN --help'."
   exit 1
fi
# }}}

# source specified configuration file {{{
if [ -n "$CONFIGFILE" ] ; then
   einfo "Reading specified config file $CONFIGFILE."
   if ! . "$CONFIGFILE" ; then
      eerror "Error reading config file $CONFIGFILE" ; eend 1 ; exit 1
   fi
fi
# }}}

# backwards compability checks {{{
if [ -n "$GROOT" ] ; then
   echo "Error: you seem to have \$GROOT configured." >&2
   echo "This variable is no longer supported, please visit the" >&2
   echo "grml-debootstrap documentation for details." >&2
   exit 1
fi

if echo "$GRUB" | grep -q '^hd' ; then
   echo "Error: this syntax for the grub configuration variable is no longer supported." >&2
   echo "Please do not use hd... any longer but /dev/sdX instead." >&2
   exit 1
fi
# }}}

# welcome screen {{{
welcome_dialog()
{
   dialog --title "$PN" --yesno "Welcome to the interactive configuration of ${PN}.
Do you want to continue installing Debian using this frontend?" 0 0
}
# }}}

# ask for target {{{
prompt_for_target()
{
  AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
               sed 's/*//' | \
               grep -v 'Extended$' | \
               gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}'; ls /dev/md* 2>/dev/null || true);

  if [ -z "$AVAILABLE_PARTITIONS" ] ; then
     dialog --title "$PN" --trim \
     --msgbox "Sorry, no partitions found. Please configure your
     harddisks (see /proc/partitions) using a tool like fdisk,
     cfdisk, gpart, gparted,..." 0 0
     exit 0
  fi

  PARTITION_LIST=$(for i in $(echo $AVAILABLE_PARTITIONS) ; do
                       echo "$i $(blkid -s TYPE -o value $i 2>/dev/null || echo [no_filesystem_yet])"
                   done)

  TARGET=$(dialog --title "$PN" --single-quoted --stdout \
         --menu "Please select the target partition:" 0 0 0 \
         $PARTITION_LIST)
}
# }}}

# ask for bootmanager {{{
prompt_for_bootmanager()
{
  ADDITIONAL_PARAMS=""

  if echo "$TARGET" | grep -q "/dev/md" ; then
     MBRPART="all disks of Software RAID $TARGET"
  else
     # figure out whole disk device
     found=
     for device in /dev/disk/by-id/*
     do
        [ $(readlink -f $device) = ${TARGET} ] || continue
        found=1
        break
     done
     [ -n "$found" ] && MBRDISK=$(echo ${device}|sed -e 's/-part[0-9][0-9]*$//')
     if [ -e "$MBRDISK" ]; then
        MBRDISK=$(readlink -f $MBRDISK)
     else
        # fall back to old behaviour
        MBRDISK=$(echo ${TARGET} | sed -e 's/[0-9][0-9]*$//')
     fi

     MBRPART="MBR of $MBRDISK"
  fi

  for device in cciss/c0d0 sda hda; do
    if [ /dev/$device != ${MBRDISK} ]; then
      grep -q $device /proc/partitions && \
      ADDITIONAL_PARAMS="$ADDITIONAL_PARAMS:$device:install bootmanager grub into MBR of /dev/$device"
    fi
  done
  ADDITIONAL_PARAMS=${ADDITIONAL_PARAMS#:}

  OIFS="$IFS"; IFS=:

  GETMBR=$(dialog --stdout --title "$PN" --default-item mbr \
          --menu "Where do you want to install the bootmanager grub?" 0 0 0 \
            mbr       "install bootmanager into $MBRPART" \
            nowhere   "do not install bootmanager at all" \
          ${ADDITIONAL_PARAMS})
  [ $? -eq 0 ] || bailout 3
  IFS="$OIFS"

  case "$GETMBR" in
    mbr)
      # /dev/md0: has to be installed in MBR of /dev/md0 and not in /dev/md:
      if echo "$TARGET" | grep -q "/dev/md" ; then
         # using sw-raid:
         if [ -n "$SELECTED_PARTITIONS" ] ; then
            GRUB=$(echo ${SELECTED_PARTITIONS} | awk '{print $1}') # use first disk only
         else
            GRUB="$TARGET"
         fi
      else
        GRUB="$MBRDISK"
      fi
      ;;
    hda)
      GRUB="/dev/hda"
      ;;
    sda)
      GRUB="/dev/sda"
      ;;
    nowhere)
      GRUB=''
      ;;
  esac
}
# }}}

# ask for Debian release {{{
prompt_for_release()
{
  [ -n "$RELEASE" ] && DEFAULT_RELEASE="$RELEASE" || DEFAULT_RELEASE='lenny'
  RELEASE="$(dialog --stdout --title "${PN}" --default-item $DEFAULT_RELEASE --menu \
            "Please enter the Debian release you would like to use for installation:" \
            0 50 3 \
            lenny    Debian/stable \
            squeeze  Debian/testing \
            sid      Debian/unstable)"
}
# }}}

# ask for hostname {{{
prompt_for_hostname()
{
  HOSTNAME="$(dialog --stdout --title "${PN}" --inputbox \
            "Please enter the hostname you would like to use for installation:" \
            0 0 $HOSTNAME)"
}
# }}}

# ask for password {{{
prompt_for_password()
{
     ROOTPW1='PW1'
     ROOTPW2='PW2'
     while [ "$ROOTPW1" != "$ROOTPW2" ]; do
       ROOTPW1=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
       "Please enter the password for the root account:" 10 60)
       ROOTPW2=$(dialog --insecure --stdout --title "${PN}" --passwordbox \
       "Please enter the password for the root account again for \
       confirmation:" 10 60)

       if [ "$ROOTPW1" != "$ROOTPW2" ]; then
         $(dialog --stdout --title "${PN}" --ok-label \
         "Retry" --msgbox "Passwords do not match!" 10 60)
       fi
     done
     ROOTPASSWORD="$ROOTPW1"
}
# }}}

# ask for Debian mirror {{{
prompt_for_mirror()
{
  [ -n "$ISO" ] && DEFAULT_MIRROR='local' || DEFAULT_MIRROR='net'

  CHOOSE_MIRROR=$(dialog --stdout --title "$PN" --default-item $DEFAULT_MIRROR \
          --menu "Where do you want to install from?" 0 0 0 \
            net   "install via network (downloading from mirror)" \
            local "install from local directory/mirror"
          )

  if [ "$CHOOSE_MIRROR" = 'net' ] ; then
     [ -n "$MIRROR" ] || MIRROR='http://cdn.debian.net/debian'
     MIRROR="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter Debian mirror you would like to use for installing packages." \
               0 0 $MIRROR)"
  else # CHOOSE_MIRROR == local
     [ -n "$ISO" ] || ISO='/mnt/mirror'
     ISO="$(dialog --stdout --title "${PN}" --inputbox \
               "Please enter directory name you would like to use for installing packages." \
               0 0 $ISO)"
  fi
}
# }}}

# software raid setup {{{
config_swraid_setup()
{
TMPFILE=$(mktemp)

# Currently we support only raid1:
RAIDLEVEL='raid1'

#RAIDLEVEL=$(dialog --stdout --title "$PN" --default-item raid1 \
#                   --menu "Which RAID level do you want to use?" 0 0 0 \
#                     raid1 "Software RAID level 1" \
#                     raid5 "Software RAID level 5")
#[ $? -eq 0 ] || bailout 20

MD_LIST=$(for i in $(seq 0 9) ; do
            awk '{print $4}' /proc/partitions | grep -q md$i || \
            echo "/dev/md$i /dev/md$i"
          done)

TARGET=$(dialog --stdout --title "$PN" --default-item /dev/md0 \
--menu "Which device do you want to use for ${RAIDLEVEL}?

Notice: activated devices will not be listed for security reasons. Anyway, please make sure the selected device is not in use already!" 0 0 0 \
$MD_LIST)
[ $? -eq 0 ] || bailout 20

AVAILABLE_PARTITIONS=$(LANG=C fdisk -l 2>/dev/null | \
             sed 's/*//' | \
             grep -v 'Extended$' | \
             gawk -v num=0 -v ORS=' ' '/^\/dev\// {print $1}')
[ -n "$AVAILABLE_PARTITIONS" ] || echo "FIXME: no partitions available?"
PARTITION_LIST=$(for i in $(echo $AVAILABLE_PARTITIONS) ; do
                     echo "$i $(blkid -s TYPE -o value $i 2>/dev/null || echo [no_filesystem_yet]) off"
                 done)

dialog --title "$PN" --separate-output \
       --checklist "Please select the partitions you would like to use for your $RAIDLEVEL on ${TARGET}:" 0 0 0 \
       $PARTITION_LIST 2>$TMPFILE
RETVAL=$?
SELECTED_PARTITIONS="$(cat $TMPFILE)"

NUM_PARTITIONS=0
for i in $(cat $TMPFILE) ; do
   NUM_PARTITIONS=$((${NUM_PARTITIONS}+1))
done

# force metadata version 0.90 for lenny so old grub can boot from this array.
METADATA_VERSION=""
if [ $RELEASE = "lenny" ]; then
   METADATA_VERSION="-e0"
fi

ERRORFILE=$(mktemp)
set +e
# TODO: better error handling?
yes | mdadm --create "${TARGET}" --level="${RAIDLEVEL}" \
      --raid-devices="${NUM_PARTITIONS}" ${METADATA_VERSION} ${SELECTED_PARTITIONS} >/dev/null 2>$ERRORFILE
RC=$?
set -e

if [ "$RC" = 0 ] ; then
   dialog --title "$PN" --msgbox \
   "Creating $TARGET was successful." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
else
   dialog --title "$PN" --msgbox \
   "There was an error setting up $TARGET:

$(cat $ERRORFILE)

Exiting." 0 0
   rm -f "$TMPFILE" "$ERRORFILE"
   exit 1
fi

}

prompt_for_swraid()
{
if dialog --stdout --title "$PN" \
          --defaultno --yesno "Do you want to configure Software RAID?

Please notice that only RAID level 1 is supported by ${PN} currently. Configuration will take place using mdadm." 0 0 ; then
  config_swraid_setup
fi
}
# }}}

# user should recheck his configuration {{{
# support full automatic installation:
checkforrun() {
   dialog --timeout 10 --title "$PN" \
          --yesno "Do you want to stop at this stage?

Notice: you are running ${PN} in non-interactive mode.
${PN} will install Debian ${RELEASE} on ${TARGET}.
Last chance to quit. Timeout of 10 seconds running....

Do you want to stop now?" 0 0 2>/dev/null
}

# make sure the user is aware of the used configuration {{{
checkconfiguration()
{
if [ -n "$AUTOINSTALL" ] ; then
   if checkforrun ; then
      eerror "Exiting as requested" ; eend 0
      exit 1
   fi
elif [ -n "$INTERACTIVE" ] ; then

   INFOTEXT="Please recheck configuration before execution:
   "
   [ -n "$TARGET" ]  && INFOTEXT="$INFOTEXT
   Target:          $TARGET"
   [ -n "$GRUB" ]    && INFOTEXT="$INFOTEXT
   Install grub:    $GRUB"
   [ -n "$RELEASE" ] && INFOTEXT="$INFOTEXT
   Using release:   $RELEASE"
   [ -n "$HOSTNAME" ] && INFOTEXT="$INFOTEXT
   Using hostname   $HOSTNAME"
   [ -n "$MIRROR" ]  && INFOTEXT="$INFOTEXT
   Using mirror:    $MIRROR"
   [ -n "$ISO" ]  && INFOTEXT="$INFOTEXT
   Using ISO:       $ISO"

   INFOTEXT="$INFOTEXT

Is this ok for you? Notice: selecting 'No' will exit ${PN}."

   dialog --title "$PN" --no-collapse \
          --yesno "$INFOTEXT" 0 0

else # if not running automatic installation display configuration and prompt for execution:
   einfo "$PN - Please recheck configuration before execution:"
   echo
   echo "   Target:          $TARGET"

   # do not display if MNTPOINT is the default one
   case "$MNTPOINT" in /mnt/debootstrap*) ;; *) echo "   Mount point:     $MNTPOINT" ;; esac

   [ -n "$GRUB" ]     && echo "   Install grub:    $GRUB" || echo "   Install grub:    no"
   [ -n "$RELEASE" ]  && echo "   Using release:   $RELEASE"
   [ -n "$MIRROR" ]   && echo "   Using mirror:    $MIRROR"
   [ -n "$HOSTNAME" ] && echo "   Using hostname:  $HOSTNAME"
   [ -n "$ISO" ]      && echo "   Using ISO:       $ISO"

   echo "   Important! Continuing will delete all data from ${TARGET}!"

   echo
   einfon "Is this ok for you? [y/N] "
   read a
   if ! [ "$a" = 'y' -o "$a" = 'Y' ] ; then
      eerror "Exiting as requested." ; eend 1
      exit 1
   fi
fi
}
# }}}

# interactive mode {{{
interactive_mode()
{
  welcome_dialog

  prompt_for_release

  prompt_for_swraid

  prompt_for_target

  prompt_for_bootmanager

  prompt_for_hostname

  prompt_for_password

  prompt_for_mirror
}

# run interactive mode if we didn't get the according configuration yet
if [ -z "$TARGET" -o -n "$INTERACTIVE" ] ; then
   # only target might be unset, so make sure the INTERACTIVE flag is set as well
   INTERACTIVE=1
   interactive_mode
fi
# }}}

checkconfiguration

# finally make sure at least $TARGET is set [the partition for the new system] {{{
if [ -n "$TARGET" ] ; then
   SHORT_TARGET="${TARGET##*/}"
else
   eerror "Please adjust $CONFFILES/config or..."
   eerror "... use the interactive version for configuration before running ${0}" ; eend 1
   exit 1
fi
# }}}

# stages setup {{{
if [ -z "$STAGES" ] ; then
   STAGES="/var/cache/grml-debootstrap/stages_${SHORT_TARGET}"
   [ -d "$STAGES" ] || mkdir -p "$STAGES"
fi

if [ -r "$STAGES"/grml-debootstrap ] ; then
   if grep -q done $STAGES/grml-debootstrap ; then
      eerror "Error: grml-debootstrap has been executed already, won't continue therefore."
      eerror "If you want to re-execute grml-debootstrap just manually remove ${STAGES}" ; eend 1
   fi
fi
# }}}

# partition handling {{{
PARTITION=''
DIRECTORY=''

set_target_directory(){
    # assume we are installing into a directory, don't run mkfs and grub related stuff therefore
    DIRECTORY=1
    MNTPOINT="$TARGET"
    MKFS=''
    TUNE2FS=''
    FSCK=''
    GRUB=''
    # make sure we normalise the path to an absolute directory name so something like:
    #  mkdir -p foo/a bar/a; (cd foo; grml-debootstrap -t a)&; (cd bar; grml-debootstrap -t a)&; wait
    # works
    TARGET="$(readlink -f $TARGET)"
}

if [ -b "$TARGET" ] ; then
    PARTITION=1
else
    set_target_directory
fi
# }}}

# architecture setup {{{
if [ -n "$ARCH" ] ; then
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
else
   ARCH="$(dpkg --print-architecture)"
   ARCHCMD="--arch $ARCH"
   ARCHINFO=" (${ARCH})"
fi
# }}}

# keyring setupt {{{
KEYRING=""
if [ "$SECURE" = 'yes' ] ; then
   if [ -e '/etc/apt/trusted.gpg' ] ; then
      KEYRING="--keyring /etc/apt/trusted.gpg"
   else
      eerror "Could not find /etc/apt/trusted.gpg."
   fi
else
   ewarn "Not checking Release signatures!"
fi
# }}}

# make sure we have the right syntax when using an iso image {{{
if [ -n "$ISO" ] ; then
   case $ISO in
      file*) # do nothing
      ;;
      *)
      ISO=file:$1
      ;;
   esac
fi
ISODIR=${ISO##file:}
ISODIR=${ISODIR%%/}
# }}}

# helper functions {{{
# we want to exit smoothly and clean:
bailout(){
  # make sure $TARGET is not mounted when exiting grml-debootstrap
  if [ -n "$MNTPOINT" ] ; then
     if grep -q $MNTPOINT /proc/mounts ; then
        # make sure nothing is left inside chroot so we can unmount it
        [ -x "$MNTPOINT"/etc/init.d/ssh   ] && "$MNTPOINT"/etc/init.d/ssh stop
        [ -x "$MNTPOINT"/etc/init.d/mdadm ] && "$MNTPOINT"/etc/init.d/mdadm stop
        # ugly, but make sure we really don't leave anything (/proc /proc is intended)
        for ARG in /sys /proc /proc ; do
          [ -x "$MNTPOINT"/bin/umount ] && chroot "$MNTPOINT" umount $ARG >/dev/null 2>&1 || true
        done
        umount "$MNTPOINT"/dev >/dev/null 2>&1 || true

        [ -d "$MNTPOINT/$ISODIR" ] && umount "$MNTPOINT/$ISODIR" >/dev/null 2>&1 || true

        if [ -n "$DIRECTORY" ] ; then
          einfo "Not unmounting $MNTPOINT as you requested me to install into a directory of your own choice." ; eend 0
        else
          einfo "Unmounting $MNTPOINT" ; umount "$MNTPOINT" ; eend $?
        fi

        if [ -n "$STAGES" ] ; then
           echo -n "Removing stages directory ${STAGES}: "
           rm -rf "$STAGES" && echo done
        fi

        # remove directory only if we used the default with process id inside the name
        if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
           einfo "Removing directory ${MNTPOINT}" ; rmdir $MNTPOINT ; eend $?
        fi
     fi
  fi

  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$3" ] && einfo "Notice: just remove $STAGES/$3 to reexecute the stage"

  exit "$EXIT"
}
trap bailout HUP INT QUIT TERM

# we want to execute all the functions only once, simple check for it:
stage() {
  if [ -n "$2" ] ; then
     echo "$2" > "${STAGES}/${1}"
     return 0
  elif grep -q done "${STAGES}/${1}" 2>/dev/null ; then
     ewarn "Notice: stage $1 has been executed already, skipping execution therefore." ; eend 0
     eindent
       ewarn "To reexecute it clean up the according directory inside $STAGES" ; eend 0
     eoutdent
     return 1
  fi
}
# }}}

# create filesystem {{{
mkfs() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, skipping mkfs stage."
  else
    if grep -q "$TARGET" /proc/mounts ; then
      eerror "$TARGET already mounted, exiting to avoid possible damage. (Manually unmount $TARGET)" ; eend 1
      exit 1
    fi

    if [ -n "$MKFS" ] ; then
       einfo "Running $MKFS on $TARGET"
       $MKFS $TARGET ; RC=$?

       # make sure /dev/disk/by-uuid/... is up2date, otherwise grub
       # will fail to detect the uuid in the chroot
       if echo "$TARGET" | grep -q "/dev/md" ; then
         blockdev --rereadpt "${TARGET}"
       else
         blockdev --rereadpt "${TARGET%%[0-9]*}"
       fi
       # give the system 2 seconds, otherwise we might run into
       # race conditions :-/
       sleep 2

       eval $(blkid -o udev $TARGET 2>/dev/null)
       [ -n "$ID_FS_UUID" ] && TARGET_UUID="$ID_FS_UUID" || TARGET_UUID=""

       eend $RC
    fi

  fi
}
# }}}

# modify filesystem settings {{{
tunefs() {
  if [ -n "$TUNE2FS" ] && echo "$MKFS" | grep -q "mkfs.ext" ; then
     einfo "Disabling automatic filesystem check on $TARGET via tune2fs"
     $TUNE2FS $TARGET
     eend $?
  fi
}
# }}}

# mount the new partition or if it's a directory do nothing at all {{{
mount_target() {
  if [ -n "$DIRECTORY" ] ; then
     einfo "Running grml-debootstrap on a directory, nothing to mount."
  else
     if grep -q $TARGET /proc/mounts ; then
        ewarn "$TARGET already mounted, continuing anyway." ; eend 0
     else
       [ -d "$MNTPOINT" ] || mkdir -p "$MNTPOINT"
       einfo "Mounting $TARGET to $MNTPOINT"
       mount -o rw,suid,dev $TARGET $MNTPOINT
       eend $?
     fi
  fi
  if [ -n "$ISODIR" ] ; then
     einfo "Mounting Debian image loopback to $MNTPOINT/$ISODIR."
     mkdir -p "$MNTPOINT/$ISODIR"
     mount --bind "$ISODIR" "$MNTPOINT/$ISODIR"
     eend $?
  fi
}
# }}}

# install main chroot {{{
debootstrap_system() {
  if [ "$_opt_nodebootstrap" ]; then
     einfo "Skipping debootstrap as requested."
     return
  fi

  if grep -q "$MNTPOINT" /proc/mounts || [ -n "$DIRECTORY" ] ; then
     einfo "Running $DEBOOTSTRAP $DEBOOTSTRAP_OPT for release ${RELEASE}${ARCHINFO} using ${MIRROR}${ISO}"
     if [ -n "$MIRROR" ] ; then
        einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $MIRROR"
        $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $MIRROR
     else
        einfo "Executing: $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $ISO"
        $DEBOOTSTRAP $ARCHCMD $KEYRING $DEBOOTSTRAP_OPT $RELEASE $MNTPOINT $ISO
     fi
     eend $?
  else
     eerror "Error: $MNTPOINT not mounted, can not continue."
     eend 1
  fi
}
# }}}

# prepare chroot via chroot-script {{{
preparechroot() {
  einfo "Preparing chroot system"

  # provide variables to chroot system
  CHROOT_VARIABLES="/var/cache/grml-debootstrap/variables_${SHORT_TARGET}"
  touch $CHROOT_VARIABLES
  chmod 600 $CHROOT_VARIABLES # make sure nobody except root can read it
  echo "# Configuration of ${PN}"                              > $CHROOT_VARIABLES
  [ -n "$ARCH" ]          && echo "ARCH=$ARCH"                 >> $CHROOT_VARIABLES
  [ -n "$GRUB" ]          && echo "GRUB=$GRUB"                 >> $CHROOT_VARIABLES
  [ -n "$HOSTNAME" ]      && echo "HOSTNAME=$HOSTNAME"         >> $CHROOT_VARIABLES
  [ -n "$INSTALL_NOTES" ] && echo "INSTALL_NOTES=$INSTALL_NOTES" >> $CHROOT_VARIABLES
  [ -n "$ISODIR" ]        && echo "ISODIR=$ISO"                >> $CHROOT_VARIABLES
  [ -n "$ISO" ]           && echo "ISO=$ISO"                   >> $CHROOT_VARIABLES
  [ -n "$MIRROR" ]        && echo "MIRROR=$MIRROR"             >> $CHROOT_VARIABLES
  [ -n "$KEEP_SRC_LIST" ] && echo "KEEP_SRC_LIST=$KEEP_SRC_LIST" >> $CHROOT_VARIABLES
  [ -n "$PACKAGES" ]      && echo "PACKAGES=$PACKAGES"         >> $CHROOT_VARIABLES
  [ -n "$ROOTPASSWORD" ]  && echo "ROOTPASSWORD=$ROOTPASSWORD" >> $CHROOT_VARIABLES
  [ -n "$TARGET" ]        && echo "TARGET=$TARGET"             >> $CHROOT_VARIABLES
  [ -n "$TARGET_UUID" ]   && echo "TARGET_UUID=$TARGET_UUID"   >> $CHROOT_VARIABLES
  [ -n "$RM_APTCACHE" ]   && echo "RM_APTCACHE=$RM_APTCACHE"   >> $CHROOT_VARIABLES

  cp $VERBOSE $CONFFILES/chroot-script $MNTPOINT/bin/chroot-script
  chmod 755 $MNTPOINT/bin/chroot-script
  [ -d "$MNTPOINT"/etc/debootstrap/ ] || mkdir "$MNTPOINT"/etc/debootstrap/

  # make sure we have our files for later use via chroot-script
  cp $VERBOSE $CONFFILES/config    $MNTPOINT/etc/debootstrap/
  # make sure we adjust the configuration variables accordingly:
  sed -i "s#RELEASE=.*#RELEASE=\"$RELEASE\"#" $MNTPOINT/etc/debootstrap/config
  sed -i "s#TARGET=.*#TARGET=\"$TARGET\"#"    $MNTPOINT/etc/debootstrap/config
  sed -i "s#GRUB=.*#GRUB=\"$GRUB\"#"          $MNTPOINT/etc/debootstrap/config

  # install notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "$INSTALL_NOTES" ] && cp "$INSTALL_NOTES" $MNTPOINT/etc/debootstrap/
  fi

  # package selection:
  cp $VERBOSE ${_opt_packages:-$CONFFILES/packages} \
    $MNTPOINT/etc/debootstrap/packages

  # debconf preseeding:
  _opt_debconf=${_opt_debconf:-$CONFFILES/debconf-selections}
  [ -f $_opt_debconf -a "$DEBCONF" = 'yes' ] && \
    cp $VERBOSE $_opt_debconf $MNTPOINT/etc/debootstrap/debconf-selections

  # copy scripts that should be executed inside the chroot:
  _opt_chroot_scripts=${_opt_chroot_scripts:-$CONFFILES/chroot-scripts/}
  [ -d $_opt_chroot_scripts -a "$CHROOT_SCRIPTS" = 'yes' ] && {
    mkdir -p $MNTPOINT/etc/debootstrap/chroot-scripts
    cp -a $VERBOSE $_opt_chroot_scripts/* $MNTPOINT/etc/debootstrap/chroot-scripts/
  }

  # notice: do NOT use $CHROOT_VARIABLES inside chroot but statically file instead!
  cp $VERBOSE $CHROOT_VARIABLES  $MNTPOINT/etc/debootstrap/variables

  cp $VERBOSE -a -L $CONFFILES/extrapackages/ $MNTPOINT/etc/debootstrap/

  # make sure we can access network [relevant for cdebootstrap]
  [ -f "$MNTPOINT/etc/resolv.conf" ] || cp $VERBOSE /etc/resolv.conf $MNTPOINT/etc/resolv.conf

  # provide system's /etc/hosts to the target:
  if ! [ -f "$MNTPOINT/etc/hosts" ] ; then
     cp $VERBOSE /etc/hosts $MNTPOINT/etc/hosts
  fi

  # setup default locales
  [ -n "$LOCALES" ] && cp $VERBOSE $CONFFILES/locale.gen  $MNTPOINT/etc/locale.gen

  # MAKEDEV is just a forking bomb crap, let's do it on our own instead :)
  ( cd $MNTPOINT/dev && tar zxf /etc/debootstrap/devices.tar.gz )

  # copy any existing files to chroot
  [ -d $CONFFILES/bin   ] && cp $VERBOSE -a -L $CONFFILES/bin/*   $MNTPOINT/bin/
  [ -d $CONFFILES/boot  ] && cp $VERBOSE -a -L $CONFFILES/boot/*  $MNTPOINT/boot/
  [ -d $CONFFILES/etc   ] && cp $VERBOSE -a -L $CONFFILES/etc/*   $MNTPOINT/etc/
  [ -d $CONFFILES/sbin  ] && cp $VERBOSE -a -L $CONFFILES/sbin/*  $MNTPOINT/sbin/
  [ -d $CONFFILES/share ] && cp $VERBOSE -a -L $CONFFILES/share/* $MNTPOINT/share/
  [ -d $CONFFILES/usr   ] && cp $VERBOSE -a -L $CONFFILES/usr/*   $MNTPOINT/usr/
  [ -d $CONFFILES/var   ] && cp $VERBOSE -a -L $CONFFILES/var/*   $MNTPOINT/var/

  # copy local network setup to chroot
  if [ -r /etc/network/interfaces -a ! -r "${MNTPOINT}"/etc/network/interfaces ] ; then
     [ -d $MNTPOINT/etc/network ] || mkdir $MNTPOINT/etc/network
     cp $VERBOSE /etc/network/interfaces $MNTPOINT/etc/network/interfaces
  fi

  # install config file providing some example entries
  if [ -r /etc/network/interfaces.examples -a ! -r "$MNTPOINT/etc/network/interfaces.examples" ] ; then
     cp /etc/network/interfaces.examples "$MNTPOINT/etc/network/interfaces.examples"
  fi

  eend 0
}
# }}}

# execute all scripts in /etc/debootstrap/pre-scripts/ {{{
execute_pre_scripts() {
   # make sure we have $MNTPOINT available for our scripts
   export MNTPOINT
   if [ -d "$_opt_pre_scripts" ] || [ "$PRE_SCRIPTS" = 'yes' ] ; then
      [ -d "$_opt_pre_scripts" ] && pre_scripts="$_opt_pre_scripts" || pre_scripts="$CONFFILES/pre-scripts/"
      for script in ${pre_scripts}/* ; do
         if [ -x "$script" ] ; then
            einfo "Executing pre-script $script"
            $script ; eend $?
         fi
      done
   fi
}
# }}}

# execute all scripts in /etc/debootstrap/scripts/ {{{
execute_scripts() {
   # make sure we have $MNTPOINT available for our scripts
   export MNTPOINT
   if [ -d "$_opt_scripts" ] || [ "$SCRIPTS" = 'yes' ] ; then
      [ -d "$_opt_scripts" ] && scripts="$_opt_scripts" || scripts="$CONFFILES/scripts/"
      for script in ${scripts}/* ; do
         if [ -x "$script" ] ; then
            einfo "Executing script $script"
            $script ; eend $?
         fi
      done
   fi
}
# }}}

# execute chroot-script {{{
chrootscript() {
  if ! [ -r "$MNTPOINT/bin/chroot-script" ] ; then
     mount_target
  fi

  if [ -x "$MNTPOINT/bin/chroot-script" ] ; then
     einfo "Executing chroot-script now"
     mount --bind /dev "$MNTPOINT"/dev
     chroot "$MNTPOINT" /bin/chroot-script ; RC=$?
     umount "$MNTPOINT"/dev
     eend $RC
  else
     eerror "Fatal: $MNTPOINT/bin/chroot-script could not be found."
     eend 1
  fi
}
# }}}

# install booloader grub {{{
grub_install() {
  if [ -z "$GRUB" ] ; then
     echo "Notice: \$GRUB not defined, will not install grub therefore."
     return 0
  fi

  if ! [ -x "$(which grub-install)" ] ; then
     echo "Error: grub-install not available. (Error while installing grub package?)"
     return 1
  fi

  if [ -n "$SELECTED_PARTITIONS" ] ; then # using sw-raid
     for device in $SELECTED_PARTITIONS ; do
        GRUB="${device%%[0-9]}"
        einfo "Installing grub on ${GRUB}:"
        grub-install --no-floppy --root-directory="$MNTPOINT" "$GRUB"
        eend $?
     done
  else
     einfo "Installing grub on ${GRUB}:"
     grub-install --no-floppy --root-directory="$MNTPOINT" "$GRUB"
     eend $?
  fi
}
# }}}

# unmount $MNTPOINT {{{
umount_chroot() {

  # display installation notes:
  if [ -n "$INSTALL_NOTES" ] ; then
     [ -r "${MNTPOINT}/${INSTALL_NOTES}" ] && cat "${MNTPOINT}/${INSTALL_NOTES}"
  fi

  if [ -n "$ISODIR" ] ; then
     if grep -q "$ISODIR" /proc/mounts ; then
        einfo "Unmount $MNTPOINT/$ISODIR"
        umount "$MNTPOINT/$ISODIR"
        eend $?
     fi
  fi

  if grep -q "$MNTPOINT" /proc/mounts ; then
     if [ -n "$PARTITION" ] ; then
        einfo "Unmount $MNTPOINT"
        umount $MNTPOINT
        eend $?
     fi
  fi
}
# }}}

# execute filesystem check {{{
fscktool() {
  if [ "$FSCK" = 'yes' ] ; then
     [ -n "$FSCKTOOL" ] || FSCKTOOL="fsck.${MKFS#mkfs.}"
     einfo "Checking filesystem on $TARGET using $FSCKTOOL"
     $FSCKTOOL $TARGET
     eend $?
  fi
}
# }}}

# now execute all the functions {{{
for i in mkfs tunefs mount_target debootstrap_system preparechroot \
         execute_pre_scripts chrootscript execute_scripts grub_install umount_chroot   \
         fscktool ; do
    if stage "${i}" ; then
       $i && ( stage "${i}" done && rm -f "${STAGES}/${i}" ) || bailout 2 "i"
    fi
done
# }}}

# finalize {{{
einfo "Removing ${CHROOT_VARIABLES}" ; rm "$CHROOT_VARIABLES" ; eend $?
einfo "Removing ${STAGES}" ; rmdir "$STAGES" ; eend $?

# Remove temporary mountpoint again
if echo "$MNTPOINT" | grep -q '/mnt/debootstrap\.' ; then
   einfo "Removing directory ${MNTPOINT}" ; rmdir "$MNTPOINT" ; eend $?
fi
# }}}

# end dialog of autoinstallation {{{
if [ -n "$AUTOINSTALL" ] ; then
   dialog --title "$PN" --msgbox \
          "Finished execution of ${PN}. Enjoy your Debian system." 0 0
else
   einfo "Finished execution of ${PN}. Enjoy your Debian system." ; eend 0
fi
# }}}

## END OF FILE #################################################################
# vim: ai tw=100 expandtab foldmethod=marker shiftwidth=3
